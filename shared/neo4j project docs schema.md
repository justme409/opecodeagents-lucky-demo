PROJECT DOCS NEO4J SCHEMA OVERVIEW
=================================

Purpose
-------
This schema describes how project-specific documents are represented in the Project Docs Neo4j database. It is designed to handle any set of uploaded construction or infrastructure documents by separating structural document content from extracted engineering knowledge (materials, work items, QA, etc.).

Database Layout
---------------
The database stores two broad groups of information:
1. Document Structure Nodes created deterministically from the source files (Documents, Sections, Tables, Figures, ContentBlocks).
2. Semantic Domain Nodes extracted via LLM enrichment (WorkItem, MaterialSpecification, ConstructionMethod, etc.).

Each node keeps a `document_number` (or similar identifier) so downstream queries can filter by document of origin. Relationships tie semantic nodes back to the document structure for traceability (`MENTIONED_IN_SECTION`, `SHOWN_IN_TABLE`, `PART_OF_SECTION`, etc.).

Key Node Labels & Core Properties
---------------------------------
Document (deterministic)
  semantic_id*        unique identifier generated by the pipeline
  document_number*    specification or contract reference
  title               document title
  filename            original file name

DocumentSection (deterministic)
  semantic_id*
  document_number*
  heading_number      section numbering (e.g. 1.2.3)
  heading             section heading text
  level               hierarchy depth
  order               ordering index
  text                full section text (when loaded with text extraction)
  parent_id           parent section identifier

Table (deterministic)
  semantic_id*
  document_number*
  content             serialized tabular data
  table_number        ordinal position within document
  parent_section      owning DocumentSection identifier

Figure (deterministic)
  semantic_id*
  document_number*
  content             caption or description
  figure_number       ordinal position
  figure_id           drawing reference ID
  url                 persistent asset reference when available
  parent_section      owning section

ContentBlock / Section (deterministic helper)
  Additional structural containers produced by the deterministic builder for fine grained anchoring.

WorkItem (semantic)
  document_number*
  item_number*
  description*
  quantity            numeric value as string to preserve formatting
  unit                measurement unit (item, m2, m3, etc.)
  rate                unit rate or price
  category            scope grouping (ESTABLISHMENT, PAVEMENT, etc.)

MaterialSpecification (semantic)
  document_number*
  name*
  specification_code  grade or mix (AC14, SD1, etc.)
  description
  properties          engineering properties
  application         usage context

ConstructionMethod (semantic)
  document_number*
  name*
  description
  work_type           excavation, placement, testing, etc.
  requirements        workmanship requirements
  sequence            order of operations

ConstructionProcedure (semantic)
  document_number*
  name*
  description
  work_type
  procedure_steps
  equipment_required
  safety_requirements
  quality_checks
  submission_required

TestRequirement (semantic)
  document_number*
  name*
  description
  acceptance_criteria
  frequency
  test_method

InspectionTestPlan (semantic)
  document_number*
  name*
  description
  work_type
  inspection_points
  test_requirements
  hold_points
  acceptance_criteria
  submission_timing
  approval_required

ReferencedStandard (semantic)
  document_number*
  name*
  code
  title
  application

Additional semantic nodes follow the same pattern with a `document_number` link and fields specific to the concept: QualityControl, ManagementPlan, ContractRequirement, EnvironmentalControl, TrafficManagementRequirement, ProjectLocation, DesignElement, DrawingReference, DesignCalculation. Schema supports extension to new node labels (`additional_node_types = True`).

Relationship Types
------------------
The pipeline generates traceability relationships between structural and semantic layers, enabling generic graph traversal:
  HAS_SECTION / HAS_SUBSECTION / NEXT_SECTION / PARENT_OF  (document hierarchy)
  HAS_TABLE / HAS_FIGURE / HAS_CONTENT                     (document assets)
  PART_OF_SECTION / MENTIONED_IN_SECTION / SHOWN_IN_TABLE  (semantic-to-structure anchors)
  SPECIFIES_MATERIAL / USES_METHOD / USES_PROCEDURE        (work execution linkages)
  CONSTRUCTS_ELEMENT / AT_LOCATION / DETAILs_SHOWN_ON      (design traceability)
  HAS_CONTRACT_REQUIREMENT / HAS_QUALITY_CONTROL           (contractual obligations)
  REQUIRES_TEST / REQUIRES_ITP / REQUIRES_PLAN             (quality & planning controls)
  REFERENCES_STANDARD / COMPLIES_WITH / BASED_ON_CALCULATION
  REQUIRES_ENVIRONMENTAL_CONTROL / REQUIRES_TRAFFIC_MANAGEMENT

The schema allows additional relationship types and patterns, so future document uploads with new semantics can still be represented without structural changes (`additional_relationship_types = True`).

Querying Strategy (Generic)
---------------------------
1. Start from `Document` or `DocumentSection` nodes filtered by `document_number` or `title`.
2. Traverse structural relationships (`HAS_SECTION`, `NEXT_SECTION`, `HAS_TABLE`, etc.) to map document layout.
3. Use semantic anchors to pull domain knowledge. Example: `MATCH (d:DocumentSection)<-[:PART_OF_SECTION]-(w:WorkItem)` retrieves work items tied to that section.
4. For cross-document insights, group on semantic labels (e.g., all `MaterialSpecification` nodes referencing `AC14`).
5. Because every semantic node keeps its originating `document_number`, results remain portable even when new documents are ingested.

Efficient Traversal Patterns
----------------------------
- **Skip generic wrappers:** Query `DocumentSection` directly instead of `__KGBuilder__`. Every section is already labeled `DocumentSection`, so `MATCH (s:DocumentSection {document_number: $doc, level: 1})` lands on top level headings.
- **Walk the hierarchy:** Navigate with `PARENT_OF` and `NEXT_SECTION` to explore only the branches that matter. Example:
  - `MATCH (root:DocumentSection {document_number: $doc, level: 1})-[:PARENT_OF]->(child) RETURN child.heading, child.level ORDER BY child.order`
- **Target content types:** Leverage asset relationships for structured payloads:
  - `HAS_TABLE` -> HTML tables (`Table.content`)
  - `HAS_FIGURE` -> captions and drawing ids
  - `AT_LOCATION` -> `ProjectLocation` chainages and descriptors
- **Filter with semantic labels:** The `semantic_labels` array highlights contextual keywords. Use `WHERE any(tag IN s.semantic_labels WHERE tag CONTAINS 'Contract')` to isolate contractual sections without scanning free text.
- **Pull scoped semantics:** Use anchor relationships to keep results grounded. Example patterns:
  - `MATCH (sec:DocumentSection {document_number: $doc})<-[:PART_OF_SECTION]-(wi:WorkItem) RETURN sec.heading, wi`
  - `MATCH (sec:DocumentSection {document_number: $doc})<-[:HAS_CONTRACT_REQUIREMENT]-(cr:ContractRequirement) RETURN sec.heading, cr`
- **Parameterize everything:** Pass `document_number` and other filters as parameters (`$doc`, `$heading`) so queries stay reusable across projects.

Extensibility
-------------
The pipeline validates the JSON schema but accepts extra node labels and relationships. To introduce new entity types, extend the schema definition in `neo4j_graphrag/experimental/components/project_documents_schema.py` or supply compatible metadata during ingestion. The `semantic_id` convention ensures deterministic IDs so repeated runs update rather than duplicate nodes.

Current Database Snapshot (for validation)
-----------------------------------------
Example counts observed on latest load (will vary with new uploads):
  Total nodes: 1019
  Dominant labels: DocumentSection (219), ReferencedStandard (96), WorkItem (90), MaterialSpecification (85), Table (78)
  Document nodes: 5 (one per source document)
  Common relationships: PART_OF_SECTION (284), MENTIONED_IN_SECTION (262), NEXT_SECTION (202), SHOWN_IN_TABLE (149)

These figures confirm that both deterministic structure and semantic enrichment are present. As additional documents are ingested the counts scale automatically without schema changes.

Usage Notes
-----------
- Always supply `document_number` when creating semantic nodes so they remain traceable.
- Leverage relationship anchors to navigate from requirements back to source sections for auditability.
- The schema is purposefully domain-rich; unused labels simply remain absent until relevant documents introduce them.
- When building automated extraction flows, prefer deterministic section traversal and anchored relationships to minimise reliance on unstructured text scans. This keeps the workflow generic across diverse document sets.


